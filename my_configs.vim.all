" Pour l'utiliser, copiez le dans
"     pour Unix et OS/2 :  ~/.vimrc
"            pour Amiga :  s:.vimrc
" pour MS-DOS and Win32 :  $VIM\_vimrc
 
colorscheme delek        " pyte more blue, desert more ... colorful xD
hi Search cterm=NONE ctermfg=black ctermbg=grey
set nocompatible        " Utilise les défauts Vim (bien mieux !)
set bs=2                " autorise l'effacement de tout en mode insertion
set ai                  " toujours utiliser l'auto-indentation
set backup              " Conserver un fichier de sauvegarde
set mouse=""
 
set viminfo='20,\"50    " Lit/écrit un fichier .viminfo, ne sauve pas plus
                        " de 50 lignes de registres
 
set history=50          " Conserve 50 lignes d'historique des commandes
set ruler               " Montre toujours la position du curseur
set textwidth=80

" remove margin if there is
set foldcolumn=0
" remove map on '0'
unmap 0

" Pour l'interface Win32: retirez l'option 't' de 'guioptions': pas d'entrée menu tearoff
" let &guioptions = substitute(&guioptions, "t", "", "g")

" N'utilise pas le mode Ex, utilise Q pour le formatage
map Q gq
 
" p en mode Visuel remplace le texte sélectionné par le registre "".
vnoremap p <Esc>:let current_reg = @"<CR>gvdi<C-R>=current_reg<CR><Esc>

" force :w! pour les fichier protégés avec sudo
"command W w !sudo tee % > /dev/null

" Ctrl+T pour lancer aspell sur le fichier
let mapleader = ","
nnoremap <leader>t :w!<CR>:!aspell check %<CR>:e! %<CR>

" Unmap q ... 
unmap <leader>q
" Ajoute des quotes autour d'un mot
nnoremap <leader>q" ciw""<Esc>P
nnoremap <leader>q' ciw''<Esc>P
" Supprime toutes les quotes autour d'un mot
nnoremap! <Leader>qd daW"=substitute(@@,"'\\\|\"","","g")<CR>P

" Pour la copy inter-instance quand VIM est compilé en -xterm_clipboard
vunmap <leader>y
vnoremap <leader>y :'<,'>w! /tmp/vitmp<CR>                                                                   
unmap <leader>p
nnoremap <leader>p :r! /tmp/vitmp<CR>


" Active la coloration syntaxique lorsque le terminal dispose de couleurs
" Active aussi la coloration de la dernière chaîne recherchée.
if &t_Co> 2 || has("gui_running")
 syntax on
 set hlsearch
endif

" Ne lance la partie suivante que si le support des autocommandes a été inclus
" lors de la compilation
if has("autocmd")

 " Dans les fichiers textes, toujours limiter la longueur du texte à 78
 " caractères
 autocmd BufRead *.txt set tw=78
 autocmd BufRead *.rst set tw=78
 augroup cprog

 " Supprime toutes les autocommandes cprog
 au!

 " Lors du début d'édition d'un fichier :
 "   Pour les fichiers C et C++ active le formatage des
 "   commentaires et l'indentation C
 "   Pour les autres fichiers, les désactive.
 "   Ne pas changer l'ordre, il est important que la ligne
 "   avec * arrive avant.
 autocmd FileType *      set formatoptions=tcql nocindent comments&
 autocmd FileType c,cpp  set formatoptions=croql cindent comments=sr:/*,mb:*,el:*/,://
 augroup END
 augroup gzip

 " Supprime toutes les autocommandes gzip
 au!

 " Active l'édition des fichiers gzippés
 " Active le mode binaire avant de lire le fichier
 autocmd BufReadPre,FileReadPre        *.gz,*.bz2 set bin
 autocmd BufReadPost,FileReadPost      *.gz call GZIP_read("gunzip")
 autocmd BufReadPost,FileReadPost      *.bz2 call GZIP_read("bunzip2")
 autocmd BufWritePost,FileWritePost    *.gz call GZIP_write("gzip")
 autocmd BufWritePost,FileWritePost    *.bz2 call GZIP_write("bzip2")
 autocmd FileAppendPre                 *.gz call GZIP_appre("gunzip")
 autocmd FileAppendPre                 *.bz2 call GZIP_appre("bunzip2")
 autocmd FileAppendPost                *.gz call GZIP_write("gzip")
 autocmd FileAppendPost                *.bz2 call GZIP_write("bzip2")

 " Après la lecture du fichier compressé : décompresse le texte dans le
 " buffer avec "cmd"
 fun! GZIP_read(cmd)
 let ch_save = &ch
 set ch=2
 execute "'[,']!" . a:cmd
 set nobin
 let &ch = ch_save
 execute ":doautocmd BufReadPost " . expand("%:r")
 endfun
 
 " Après l'écriture du fichier compressé : compresse le fichier écrit avec "cmd"
 fun! GZIP_write(cmd)
 if rename(expand("<afile>"), expand("<afile>:r")) == 0
 execute "!" . a:cmd . " <afile>:r"
 endif
 endfun
 
 " Avant l'ajout au fichier compressé : décompresse le fichier avec "cmd"
 fun! GZIP_appre(cmd)
 execute "!" . a:cmd . " <afile>"
 call rename(expand("<afile>:r"), expand("<afile>"))
 endfun
 augroup END
endif " has("autocmd")

filetype plugin indent on
